import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import entryDefinitions from '../config/frontend-entries.json' with { type: 'json' };

type EntryDefinitions = Record<string, string>;

interface ManifestRecord {
  file: string;
  src?: string;
  css?: string[];
  imports?: string[];
  isEntry?: boolean;
  name?: string;
}

type Manifest = Record<string, ManifestRecord>;

/** Scripts and styles needed to bootstrap the requested frontend entries. */
interface ClientAssetsResult {
  scripts: string[];
  styles: string[];
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_ROOT = path.join(__dirname, '..');
const VITE_MANIFEST_PATH = path.join(PROJECT_ROOT, 'build', 'vite', '.vite', 'manifest.json');
const PUBLIC_ASSET_PREFIX = '/assets/';
const DEV_CLIENT_ENTRY = path.posix.join(PUBLIC_ASSET_PREFIX, '@vite/client');
const DEV_ENTRY_STYLES = new Map<string, string[]>([
  // Ensure core styles are linked eagerly during development to avoid a flash of
  // unstyled content while Vite injects CSS via JS.
  ['lib', [
    'frontend/styles/vendor.css',
    'frontend/styles/style.less'
  ]]
]);

/** Map between canonical entry names and their manifest source paths. */
const ENTRY_MAP = new Map<string, string>(Object.entries(entryDefinitions as EntryDefinitions));

let cachedManifest: Manifest | null = null;

/** Returns `true` when the production Vite build should be preferred. */
function shouldUseProdBuild(): boolean {
  return process.env.NODE_ENV === 'production' || process.env.LIBREVIEWS_VITE_DEV_SERVER === 'off';
}

/** Normalizes various entry references into canonical manifest keys. */
function normalizeEntryName(value: unknown): string | null {
  if (!value || typeof value !== 'string')
    return null;

  let normalized = value.trim();

  normalized = normalized.replace(/^frontend\/entries\//, '');
  normalized = normalized.replace(/\.m?js$/, '');

  return normalized;
}

/** Validates that a requested entry exists in the known manifest map. */
function ensureValidEntry(value: unknown): string | null {
  const normalized = normalizeEntryName(value);
  if (!normalized)
    return null;
  if (!ENTRY_MAP.has(normalized))
    throw new Error(`Unknown frontend entry "${value}". Known entries: ${Array.from(ENTRY_MAP.keys()).join(', ')}.`);
  return normalized;
}

/** Converts a manifest-relative path into a public asset URL. */
function toPublicPath(relative: string): string {
  return path.posix.join(PUBLIC_ASSET_PREFIX, relative);
}

/** Reads and caches the Vite manifest generated by `npm run build`. */
function loadProductionManifest(): Manifest {
  if (cachedManifest)
    return cachedManifest;
  try {
    const data = fs.readFileSync(VITE_MANIFEST_PATH, 'utf8');
    cachedManifest = JSON.parse(data) as Manifest;
  } catch (error) {
    if (error instanceof Error)
      error.message = `Unable to load Vite manifest at ${VITE_MANIFEST_PATH}. Run "npm run build" before starting the server. Original error: ${error.message}`;
    throw error;
  }
  return cachedManifest;
}

/**
 * Walks manifest dependencies to gather CSS assets for the given entry while
 * avoiding cycles.
 */
function collectImportedCss(manifest: Manifest, manifestKey: string, collectedCss: Set<string>, seen: Set<string> = new Set()): void {
  if (seen.has(manifestKey))
    return;
  seen.add(manifestKey);

  const record = manifest[manifestKey];
  if (!record)
    return;

  if (Array.isArray(record.css))
    record.css.forEach(cssPath => collectedCss.add(toPublicPath(cssPath)));

  if (Array.isArray(record.imports))
    record.imports.forEach(depKey => collectImportedCss(manifest, depKey, collectedCss, seen));
}

/** Builds a fake manifest when the Vite dev server serves assets directly. */
function getDevManifest(): Manifest {
  const manifest: Manifest = {};
  ENTRY_MAP.forEach((sourcePath, entryName) => {
    manifest[sourcePath] = {
      file: toPublicPath(sourcePath),
      isEntry: true,
      name: entryName,
      src: sourcePath
    };
  });
  return manifest;
}

/** Selects either the production or development manifest. */
function getManifest(): Manifest {
  return shouldUseProdBuild() ? loadProductionManifest() : getDevManifest();
}

/**
 * Resolves the scripts and styles required to serve the requested frontend
 * bundles. Entries are deduplicated and always include the base `lib` bundle.
 */
function getClientAssets(requestedEntries?: unknown[]): ClientAssetsResult {
  const ordered: string[] = [];
  if (Array.isArray(requestedEntries)) {
    const seen = new Set<string>();
    requestedEntries.forEach(entry => {
      const normalized = ensureValidEntry(entry);
      if (normalized && normalized !== 'lib' && !seen.has(normalized)) {
        seen.add(normalized);
        ordered.push(normalized);
      }
    });
  }

  const orderedEntries = ['lib', ...ordered];
  const scripts = new Set<string>();
  const styles = new Set<string>();

  if (shouldUseProdBuild()) {
    const manifest = loadProductionManifest();

    orderedEntries.forEach(entryName => {
      const manifestKey = ENTRY_MAP.get(entryName);
      if (!manifestKey)
        throw new Error(`Unknown frontend entry "${entryName}". Known entries: ${Array.from(ENTRY_MAP.keys()).join(', ')}.`);
      const record = manifest[manifestKey];

      if (!record)
        throw new Error(`Missing Vite manifest entry for "${manifestKey}". Run "npm run build" to refresh assets.`);

      scripts.add(toPublicPath(record.file));

      if (Array.isArray(record.css))
        record.css.forEach(cssPath => styles.add(toPublicPath(cssPath)));

      if (Array.isArray(record.imports))
        record.imports.forEach(depKey => collectImportedCss(manifest, depKey, styles));
    });
  } else {
    scripts.add(DEV_CLIENT_ENTRY);
    orderedEntries.forEach(entryName => {
      const sourcePath = ENTRY_MAP.get(entryName);

      if (!sourcePath)
        throw new Error(`Unknown frontend entry "${entryName}". Known entries: ${Array.from(ENTRY_MAP.keys()).join(', ')}.`);

      scripts.add(toPublicPath(sourcePath));

      const stylesForEntry = DEV_ENTRY_STYLES.get(entryName);
      if (Array.isArray(stylesForEntry))
        stylesForEntry.forEach(stylePath => styles.add(toPublicPath(stylePath)));
    });
  }

  return {
    scripts: Array.from(scripts),
    styles: Array.from(styles)
  };
}

/** Clears the in-memory manifest cache. */
function resetManifestCache(): void {
  cachedManifest = null;
}

/** Convenience bag mirroring the previous CommonJS export shape. */
const clientAssets = {
  ENTRY_MAP,
  getClientAssets,
  getManifest,
  resetManifestCache
};

export {
  ENTRY_MAP,
  getClientAssets,
  getManifest,
  resetManifestCache
};

export default clientAssets;
